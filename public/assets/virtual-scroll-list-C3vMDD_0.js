import{d as u,c as m,b as D,o as g,_ as M,r as p,l as I,e as y,a as h}from"./index-XMO9d-si.js";const H={class:"virtual-scroll-docs"},O=u({__name:"virtual-child",setup(_){return(s,a)=>(g(),m("div",H,a[0]||(a[0]=[D(`<header class="docs-header" data-v-58a8da5d><h1 data-v-58a8da5d>虚拟滚动列表（Virtual Scrolling List）</h1><p data-v-58a8da5d>高效处理大规模数据列表的前端优化方案</p></header><main class="docs-content" data-v-58a8da5d><section class="docs-section" data-v-58a8da5d><h2 class="section-title" data-v-58a8da5d>一、适用场景</h2><div class="section-content" data-v-58a8da5d><p data-v-58a8da5d>虚拟滚动列表通过「只渲染可视区域内容」的核心思想，解决大量数据渲染导致的性能问题，主要适用于以下场景：</p><div class="scene-card" data-v-58a8da5d><h3 data-v-58a8da5d>1. 超大数据量列表</h3><p data-v-58a8da5d>当需要展示<span class="highlight" data-v-58a8da5d>1000+条数据</span>时（如订单记录、用户列表、日志详情等），直接渲染全部DOM会导致：</p><ul class="scene-list" data-v-58a8da5d><li data-v-58a8da5d>页面初始化缓慢（DOM节点过多导致解析耗时）</li><li data-v-58a8da5d>滚动卡顿（浏览器重排重绘成本过高）</li><li data-v-58a8da5d>内存占用激增（大量DOM节点常驻内存）</li></ul></div><div class="scene-card" data-v-58a8da5d><h3 data-v-58a8da5d>2. 固定高度列表项场景</h3><p data-v-58a8da5d>最适合列表项高度固定的场景（如表格行、商品卡片等），此时可通过简单计算精准定位可视区域内容。</p><p class="note" data-v-58a8da5d>注：动态高度列表项也可实现，但需额外处理高度测量逻辑，复杂度更高。</p></div><div class="scene-card" data-v-58a8da5d><h3 data-v-58a8da5d>3. 交互频繁的长列表</h3><p data-v-58a8da5d>需要支持滚动、点击、悬停等交互的长列表（如聊天记录、评论区），虚拟滚动可保持交互响应速度。</p></div><div class="scene-card" data-v-58a8da5d><h3 data-v-58a8da5d>4. 移动端性能优化</h3><p data-v-58a8da5d>移动端设备硬件性能有限，大量DOM渲染易导致页面崩溃或ANR（应用无响应），虚拟滚动可显著提升兼容性。</p></div><div class="scene-card warning" data-v-58a8da5d><h3 data-v-58a8da5d>不适用场景</h3><ul class="scene-list" data-v-58a8da5d><li data-v-58a8da5d>数据量较少（如少于200条）：优化收益低于实现成本</li><li data-v-58a8da5d>列表项高度动态且不可预测：计算逻辑复杂，易出现空白或错位</li><li data-v-58a8da5d>需要频繁操作整体DOM结构（如批量拖拽排序）：虚拟滚动的局部渲染会增加逻辑复杂度</li></ul></div></div></section><section class="docs-section" data-v-58a8da5d><h2 class="section-title" data-v-58a8da5d>二、实现原理</h2><div class="section-content" data-v-58a8da5d><p data-v-58a8da5d>虚拟滚动的核心是「用局部渲染模拟整体列表」，通过以下四个关键步骤实现：</p><div class="principle-step" data-v-58a8da5d><h3 data-v-58a8da5d>1. 界定可视区域范围</h3><p data-v-58a8da5d>根据容器的滚动距离和可视高度，计算当前需要显示的列表项索引范围：</p><div class="code-snippet" data-v-58a8da5d><pre data-v-58a8da5d>// 滚动距离 / 单项高度 = 起始索引
  const startIndex = Math.floor(scrollTop / itemHeight);
  // 起始索引 + 可视区域可容纳项数 = 结束索引（+2为缓冲项）
  const endIndex = startIndex + Math.ceil(containerHeight / itemHeight) + 2;</pre></div><p data-v-58a8da5d>通过上述计算，可从海量数据中筛选出「当前需要渲染的小部分数据」。</p></div><div class="principle-step" data-v-58a8da5d><h3 data-v-58a8da5d>2. 局部渲染可视内容</h3><p data-v-58a8da5d>仅渲染startIndex到endIndex范围内的列表项，而非全部数据，大幅减少DOM节点数量：</p><div class="code-snippet" data-v-58a8da5d><pre data-v-58a8da5d>// 从完整数据中截取可视部分
  const visibleData = fullData.slice(startIndex, endIndex);
  // 只渲染这部分数据（示例伪代码）
  visibleData.forEach(item =&gt; {
    renderItem(item); // 渲染单个列表项
  });</pre></div><p data-v-58a8da5d>通常会配合文档片段（DocumentFragment）减少DOM操作次数，进一步优化性能。</p></div><div class="principle-step" data-v-58a8da5d><h3 data-v-58a8da5d>3. 偏移定位可视内容</h3><p data-v-58a8da5d>通过CSS定位（transform或top）将渲染的可视项「偏移」到容器的可视区域内，模拟整体滚动效果：</p><div class="code-snippet" data-v-58a8da5d><pre data-v-58a8da5d>// 通过transform将列表向上偏移，使可视项对齐容器顶部
  virtualList.style.transform = \`translateY(\${startIndex * itemHeight}px)\`;</pre></div><p data-v-58a8da5d>原理示意图：</p><div class="principle-diagram" data-v-58a8da5d><div class="diagram-illustration" data-v-58a8da5d><div class="diagram-container" data-v-58a8da5d><div class="diagram-scrollbar" data-v-58a8da5d>滚动条</div><div class="diagram-visible-area" data-v-58a8da5d>可视区域</div><div class="diagram-rendered" data-v-58a8da5d>已渲染项</div><div class="diagram-hidden" data-v-58a8da5d>未渲染项（省略）</div></div><p data-v-58a8da5d>通过偏移，使已渲染的局部内容始终显示在可视区域内，用户感知与完整列表一致。</p></div></div></div><div class="principle-step" data-v-58a8da5d><h3 data-v-58a8da5d>4. 撑开容器高度</h3><p data-v-58a8da5d>设置虚拟列表的总高度为「完整数据量 × 单项高度」，确保滚动条长度与完整渲染时一致，保证滚动体验：</p><div class="code-snippet" data-v-58a8da5d><pre data-v-58a8da5d>// 总高度 = 数据总量 × 单项高度
  virtualList.style.height = \`\${fullData.length * itemHeight}px\`;</pre></div><p data-v-58a8da5d>这一步是模拟「完整列表存在」的关键，否则滚动条会因实际DOM高度不足而无法正常滚动。</p></div><div class="principle-summary" data-v-58a8da5d><h3 data-v-58a8da5d>总结</h3><p data-v-58a8da5d>虚拟滚动通过「范围计算→局部渲染→偏移定位→高度模拟」四步，在用户无感知的情况下，用少量DOM节点实现海量数据的滚动效果，核心是「以计算换性能」。</p></div></div></section></main>`,2)])))}}),C=M(O,[["__scopeId","data-v-58a8da5d"]]),S={class:"cContainer"},n=50,b=u({__name:"virtual-scroll-list",setup(_){const s=Array.from({length:1e4},(l,d)=>`Item ${d+1}`);let a=null,i=null,c=0;const f=p(!1);function r(){if(!a||!i)return;const l=Math.floor(c/n),d=l+Math.ceil(a.clientHeight/n)+2,x=s.slice(l,d);console.log(x),i.innerHTML="";const o=document.createDocumentFragment();for(let t=l;t<d&&t<s.length;t++){console.log(t);const e=document.createElement("div");e.className="item",e.textContent=s[t],e.style.position="absolute",e.style.top=`${t*n}px`,e.style.width="100%",o.appendChild(e)}i.appendChild(o),!f.value&&(i.style.height=`${s.length*n}px`)}const v=p(!1);return I(()=>{a=document.querySelector(".__virtual-con"),i=document.querySelector(".__virtual-list"),a?.addEventListener("scroll",()=>{v.value||(v.value=!0,requestAnimationFrame(()=>{c=a.scrollTop,r(),v.value=!1}))}),r()}),(l,d)=>(g(),m("div",S,[y(C),d[0]||(d[0]=h("div",{class:"__virtual-con"},[h("div",{class:"__virtual-list"})],-1))]))}});export{b as default};
